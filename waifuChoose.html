<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AniList Character Duel</title>
  <link rel="stylesheet" href="style.css">
  <style>
    #duel-container {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
    }
    .character-card {
      text-align: center;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      width: 300px;
      background-color: #333;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease-out;
    }
    .character-card:hover {
      transform: scale(1.01);
      box-shadow: 0px 0px 15px -3px #ffffff;
      color: #fff;
      text-decoration: none;
    }
    .character-card:active {
      transform: scale(0.95);
    }
    .character-card img {
      max-height: 100%;
    }
    #final-board {
      margin-top: 20px;
    }
    #status {
      text-align: center;
      align-self: center;
      margin-top: 20px;
      width: max-content;
    }
    .character-card.highlight {
      position: relative; /* Position the card absolutely */
      transform: scale(1.4); /* Adjust scale as needed */
      transition: all 0.5s ease; /* Smooth transition for the animation */
      z-index: 10;        /* Ensure the highlighted card is on top */
    }
    .main{
      width: 60%;
      align-self: center;
    }
    #startButton{
      height: 100px;
      font-weight: 900;
      font-size: xx-large;
      text-transform: uppercase;
    }
    .topElimImg{
      width: 10%;
    }
    .finalWinner {
      border: 5px solid gold;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 140, 0, 0.6);
      animation: winner-spin 3s infinite linear;
      transform-style: preserve-3d;
      transform: scale(1.1);
      border-radius: 10px;
      display: block;
      margin: 50px auto; /* Centers the image horizontally */
    }

    @keyframes winner-spin {
      from {
        transform: rotateZ(0deg);
      }
      to {
        transform: rotateZ(360deg);
      }
    }
  </style>
</head>
<body id="body">
  <div class="main" style="display: flex; flex-direction: column;">
    <div class="element">
      <h1>Anime Character Duel</h1>
      <p>It will look for the most popular characters right now. It will try to find roughly the count specified.</p>
      <p>Choose your winner from each duel by clicking on them or pressing the left or right arrow key until only one remains!</p>
      <p>If you choose above like 600 it will take like a minute because it has to wait for the API cooldown.</p>
    </div>
    <div class="element">
      <label for="characterCount">Number of characters:</label>
      <input class="button" type="number" id="characterCount" min="2" value="1000"> 
      <button class="button" id="startButton">Start Duel</button>
    </div>
  </div>
  
  
  

  
  <div id="status"></div>
  <div id="duel-container"></div>
  <div id="final-board"></div>

  <script src="script.js"></script>
  <script>
    // Get references to the input and button elements
    const characterCountInput = document.getElementById('characterCount');
    const startButton = document.getElementById('startButton');


    let characters = [];
    let eliminated = [];
    let survivors = [];
    let currentDuel = [];
    let round = 1;

    const charactersPerPage = 50; // Number of characters to fetch per page
    let desiredCharacterCount = parseInt(document.getElementById('characterCount').value);
    
    // Add an event listener to the button
    startButton.addEventListener('click',  
    () => {
          desiredCharacterCount = parseInt(characterCountInput.value);
          console.debug("Desired: " + desiredCharacterCount)
          characters = [];
          survivors = [];
          currentDuel = [];
          eliminated = [];
          document.getElementById('final-board').innerHTML = "";
          round = 1;
          
          // Fetch characters and start the duel system
          fetchCharacters(desiredCharacterCount); 
          document.querySelector('#body').style.paddingBottom = '50vh';
          document.querySelector('#status').classList.add("element");
        });
    const pause = (time) => new Promise(resolve => setTimeout(resolve, time))    
        // Modify fetchCharacters to accept desiredCharacterCount as an argument
    async function fetchCharacters(desiredCharacterCount){
    let currentPage = 1;
    let totalCharactersFetched = 0;

    while (true) { // Keep fetching until we break explicitly
        const query = `
        query {
            Page(perPage: ${charactersPerPage}, page: ${currentPage}) {
            characters(sort: FAVOURITES_DESC) {
                name {
                full
                }
                image {
                large
                }
                gender
            }
            }
        }
        `;

        try {
        const response = await fetch('https://graphql.anilist.co/', {
            method: 'POST',
            headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            },
            body: JSON.stringify({ query: query }),
        });

        const result = await response.json();
        const newCharacters = result.data.Page.characters.filter(character => character.gender === 'Female');

        characters = characters.concat(newCharacters);
        totalCharactersFetched += newCharacters.length;
        currentPage++;

        console.debug("Total fetched: " + totalCharactersFetched)
        document.getElementById('status').textContent = "Total characters fetched: " + totalCharactersFetched;

        // Break if we've reached the desired number of characters or there are no more characters
        if (totalCharactersFetched >= desiredCharacterCount || newCharacters.length === 0) {
          console.debug("BREAK")
          break; 
        }

        } catch (error) {
          console.error('Error fetching characters:', error);
          currentPage--;
          document.getElementById('status').textContent = "API limit reached. Please wait 1 minute for access.";
          await pause(60000)
        }
    }
    console.debug("Desired: " + desiredCharacterCount)
    
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));  

        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
      }
    }

    shuffleArray(characters);


    survivors = [...characters];
    updateStatus();
    gameEnded = false;
    inputBlocked = false;
    startDuel();
    }


    function updateStatus() {
      const statusElement = document.getElementById('status');
      statusElement.innerHTML = `<h2>Round: ${round}</h2><p>Duels left: ${survivors.length}</p>`;
    }

    let duelsPerRound = 0; // Track the number of duels in the current round

    function startDuel() {
      console.debug(survivors.length);

      if (survivors.length <= 1) {
          showFinalBoard();
          gameEnded = true; // Block input after the game ends
          return;
      }

      if (duelsPerRound === 0) {
          duelsPerRound = Math.floor(survivors.length / 2);
      }

      const duelContainer = document.getElementById('duel-container');
      duelContainer.innerHTML = '';

      if (survivors.length % 2 !== 0) {
          survivors.push(survivors.shift()); // Move the first survivor to the next round if odd number of survivors
      }

      const char1 = survivors.shift();
      const char2 = survivors.shift();

      currentDuel = [char1, char2];

      displayCharacter(char1, duelContainer);
      displayCharacter(char2, duelContainer);

      duelsPerRound--;

      if (duelsPerRound === 0) {
          round++;
      }

      updateStatus();
    }
    let inputBlocked = false; // New flag to block input during animation
    let gameEnded = false; // Flag to prevent input after the game ends

    function displayCharacter(character, container) {
      const charDiv = document.createElement('div');
      charDiv.classList.add('character-card');

      const charImg = document.createElement('img');
      charImg.src = character.image.large;
      charImg.alt = character.name.full;

      // Add click event listener to the image
      charDiv.addEventListener('click', () => {
        // Find the opponent in the current duel
        const opponent = currentDuel.find(char => char !== character);
        
        // Call selectWinner with the clicked character as the winner
        selectWinner(character, opponent);
      });

      charDiv.appendChild(charImg);
      const charName = document.createElement('p');
      charName.textContent = character.name.full;
      charDiv.appendChild(charName);

      container.appendChild(charDiv);
    }

    function selectWinner(winner, loser) {
      if (inputBlocked || gameEnded) return; // If input is blocked or game ended, do nothing

      inputBlocked = true; // Block input during the animation
      survivors.push(winner);
      eliminated.push(loser);

      const winnerCard = document.querySelector(`.character-card img[src="${winner.image.large}"]`).parentElement;
      winnerCard.classList.add('highlight');

      setTimeout(() => {
          winnerCard.classList.remove('highlight');
          
          // Delay starting the next duel to allow the animation to finish
          setTimeout(() => {
              if (survivors.length === 2) {
                  round++;
              }
              inputBlocked = false; // Unblock input after the animation ends
              startDuel(); // Start next duel
          }, 500); // Adjust the delay (in milliseconds) as needed
      }, 500); 
    }
    // Handle key press for left and right arrows
    document.addEventListener('keydown', function(event) {
      if (inputBlocked || gameEnded) return; // Block input if input is blocked or game is over

      if (event.key === 'ArrowLeft') {
          selectWinner(currentDuel[0], currentDuel[1]);
      } else if (event.key === 'ArrowRight') {
          selectWinner(currentDuel[1], currentDuel[0]);
      }
    });

    function showFinalBoard() {
        const finalBoard = document.getElementById('final-board');
        finalBoard.innerHTML = `<div style="text-align: center;" class=element><h2>1. Final Winner: ${survivors[0].name.full}</h2>`;
        finalBoard.innerHTML += `<img class="finalWinner" src="${survivors[0].image.large}" alt="${survivors[0].name.full}"></div>`;

        let board = '<div class="element"><h3>Top Eliminated</h3>'; // Use <ol> for numbered list
        let rank = 2; // Initialize rank counter

        eliminated.reverse();
        console.debug(eliminated);
        eliminated.forEach(char => {
          board += `<img class="topElimImg" src=${char.image.large} alt=""><div style="font-size: larger;">${rank}. ${char.name.full}</div><br>`; // Use backticks and add <br> for line breaks
          rank++; // Increment rank, not board
        });

        board += "</div>"; // Close the div
        finalBoard.innerHTML += board;

        gameEnded = true; // Block input after the final board is displayed
    }
  </script>
</body>
</html>
