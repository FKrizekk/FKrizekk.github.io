<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AniList Character Duel</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: Arial, sans-serif;
    }
    #duel-container {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
    }
    .character-card {
      text-align: center;
      border: 1px solid #ddd;
      padding: 10px;
      width: 300px;
      background-color: #333;
      color: white;
    }
    .character-card img {
      max-height: 100%;
    }
    #final-board {
      margin-top: 20px;
    }
    #status {
      text-align: center;
      margin-top: 20px;
    }
    .character-card.highlight {
      position: relative; /* Position the card absolutely */
      transform: scale(1.4); /* Adjust scale as needed */
      transition: all 0.5s ease; /* Smooth transition for the animation */
      z-index: 10;        /* Ensure the highlighted card is on top */
    }
  </style>
</head>
<body>

  <h1>Anime Character Duel</h1>
  <p>It will look for the most popular characters. It will try to find roughly the count specified and then filter out the males so it will get you like a bit over half of what you input i think</p>
  <p>Choose your winner from each duel by pressing the left or right arrow key until only one remains!</p>
  <p>I think because of the API rate limiting it will get you like 700 max characters but that is kinda fine idk what to do with it</p>
  
  <label for="characterCount">Number of characters:</label>
  <input type="number" id="characterCount" min="2" value="1000"> 
  <button id="startButton">Start Duel</button>

  
  <div id="status"></div>
  <div id="duel-container"></div>
  <div id="final-board"></div>

  <script>
    // Get references to the input and button elements
    const characterCountInput = document.getElementById('characterCount');
    const startButton = document.getElementById('startButton');


    let characters = [];
    let survivors = [];
    let currentDuel = [];
    let round = 1;

    const charactersPerPage = 50; // Number of characters to fetch per page
    const desiredCharacterCountt = parseInt(document.getElementById('characterCount').value) || 1000; // Default to 1000 if invalid input
    
    // Add an event listener to the button
    startButton.addEventListener('click',  
    () => {
          alert("AFTER CLICKING OK, WAIITTTT FOR ITTT TO LOADDD\nTHANK YOU!!!!")
          const desiredCharacterCount = parseInt(characterCountInput.value) || 1000;

          // Fetch characters and start the duel system
          fetchCharacters(desiredCharacterCountt); 
        });

        // Modify fetchCharacters to accept desiredCharacterCount as an argument
    async function fetchCharacters(desiredCharacterCount){
    let currentPage = 1;
    let totalCharactersFetched = 0;

    while (true) { // Keep fetching until we break explicitly
        const query = `
        query {
            Page(perPage: ${charactersPerPage}, page: ${currentPage}) {
            characters(sort: FAVOURITES_DESC) {
                name {
                full
                }
                image {
                large
                }
                gender
            }
            }
        }
        `;

        try {
        const response = await fetch('https://graphql.anilist.co/', {
            method: 'POST',
            headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            },
            body: JSON.stringify({ query: query }),
        });

        const result = await response.json();
        const newCharacters = result.data.Page.characters.filter(character => character.gender === 'Female');

        characters = characters.concat(newCharacters);
        totalCharactersFetched += newCharacters.length;
        currentPage++;

        // Break if we've reached the desired number of characters or there are no more characters
        if (totalCharactersFetched >= desiredCharacterCount || newCharacters.length === 0) {
            break; 
        }

        } catch (error) {
        console.error('Error fetching characters:', error);
        break;
        }
    }
    
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));  

        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
      }
    }

    shuffleArray(characters);


    survivors = [...characters];
    updateStatus();
    startDuel();
    }

    // ... (rest of the code remains the same)

    function updateStatus() {
      const statusElement = document.getElementById('status');
      statusElement.innerHTML = `<h2>Round: ${round}</h2><p>Characters left: ${survivors.length}</p>`;
    }

    let duelsPerRound = 0; // Track the number of duels in the current round

    function startDuel() {
    if (survivors.length <= 1) {
        showFinalBoard();
        return;
    }

    if (duelsPerRound === 0) { 
        // Start of a new round, calculate the number of duels
        duelsPerRound = survivors.length / 2; 
    }

    const duelContainer = document.getElementById('duel-container');
    duelContainer.innerHTML = '';

    const char1 = survivors.shift();
    const char2 = survivors.shift();

    currentDuel = [char1, char2];

    displayCharacter(char1, duelContainer);
    displayCharacter(char2, duelContainer);

    duelsPerRound--; // Decrement the number of duels left in this round

    if (duelsPerRound === 0) {
        // All duels for this round are done, move to the next round
        round++;
    }

    updateStatus();
    }

    function displayCharacter(character, container) {
      const charDiv = document.createElement('div');
      charDiv.classList.add('character-card');

      const charImg = document.createElement('img');
      charImg.src = character.image.large;
      charImg.alt = character.name.full;

      // Add click event listener to the image
      charImg.addEventListener('click', () => {
        // Find the opponent in the current duel
        const opponent = currentDuel.find(char => char !== character);
        
        // Call selectWinner with the clicked character as the winner
        selectWinner(character, opponent);
      });

      charDiv.appendChild(charImg);
      const charName = document.createElement('p');
      charName.textContent = character.name.full;
      charDiv.appendChild(charName);

      container.appendChild(charDiv);
    }

    let eliminationRounds = []; // Track the round in which each character was eliminated

    function selectWinner(winner, loser) {
      survivors.push(winner);
      eliminationRounds[characters.indexOf(loser)] = round;

      const winnerCard = document.querySelector(`.character-card img[src="${winner.image.large}"]`).parentElement;
      winnerCard.classList.add('highlight');

      setTimeout(() => {
        winnerCard.classList.remove('highlight');

        // Delay starting the next duel to allow the animation to finish
        setTimeout(() => {
          if (survivors.length === 2) {
            round++;
          }
          startDuel();
        }, 500); // Adjust the delay (in milliseconds) as needed
      }, 500); 
    }
    // Handle key press for left and right arrows
    document.addEventListener('keydown', function(event) {
      if (event.key === 'ArrowLeft') {
        // Left arrow key selects the first character
        selectWinner(currentDuel[0], currentDuel[1]);
      } else if (event.key === 'ArrowRight') {
        // Right arrow key selects the second character
        selectWinner(currentDuel[1], currentDuel[0]);
      }
    });

    function showFinalBoard() {
        const finalBoard = document.getElementById('final-board');
        finalBoard.innerHTML = `<h2>Final Winner: ${survivors[0].name.full}</h2>`;
        finalBoard.innerHTML += `<img src="${survivors[0].image.large}" alt="${survivors[0].name.full}">`;

        // Display who survived the longest, sorted by elimination order (most recent losers first)
        let board = '<h3>Survival Board</h3><ol>'; // Use <ol> for numbered list
        let rank = 1; // Initialize rank counter

        characters.sort((a, b) => {
            const aEliminated = !survivors.includes(a);
            const bEliminated = !survivors.includes(b);

            if (aEliminated && !bEliminated) return -1; 
            if (!aEliminated && bEliminated) return 1; 

            if (aEliminated && bEliminated) {
            return eliminationRounds[characters.indexOf(b)] - eliminationRounds[characters.indexOf(a)]; 
            }

            return 0; 
        }).forEach(character => {
            board += `<li>${character.name.full} - ${survivors.includes(character) ? 'Survived' : 'Eliminated'}</li>`;
            rank++; // Increment rank for each character
        });

        board += '</ol>';
        finalBoard.innerHTML += board;
    }
  </script>

</body>
</html>
